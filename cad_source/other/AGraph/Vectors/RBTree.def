{
  This code was converted from C-language free sources by A.Chernobaev, 050602.

  Красно-черные деревья (интерфейс).

  Red-black trees (interface part).

  Красно-черные деревья - эффективная структура данных, поддерживающая операции
  вставки, поиска и удаления за время не более O(log n).

  Для создания на основе данного шаблона конкретных классов-деревьев необходимо:
  1) включить модули SysUtils, ExtType и Pointerv в секцию uses модуля;
  2) определить тип TTreeData;
  3) включить данный файл в интерфейсную часть модуля с помощью директивы $I;
  4) включить файл RBTree.imp в часть реализации с помощью директивы $I.

  Кроме того, необходимо определить функцию сравнения CMP для TTreeData:

  function CMP(const a, b: TTreeData): Integer;
  (* if a < b then CMP = -1 else if a > b then CMP:=1 else CMP:=0 *)

  Это можно сделать одним из трех способов:
  а) определить функцию CMP в части реализации перед включением в него файла
     RBTree.imp (см. п.4) - в этом случае используется простой вариант создания
     дерева с помощью конструктора Create без параметров;
  б) определить с помощью директивы $DEFINE условие компиляции USER_COMPARE
     перед включением в него данного файла (см. п.3) - в этом случае функция
     CMP передается в конструктор Create в качестве параметра;
  в) определить с помощью директивы $DEFINE условие USER_COMPARE_OBJECTS перед
     включением в него данного файла (см. п.3) - в этом случае объектная функция
     (function of object) CMP передается в конструктор Create в качестве
     параметра.
}

const
  BLACK = 0;
  RED = 1;

type
  { we don't store the node color assuming the color is "RED" iff the lowest
    bit of TNode.parent is set }

  {$IFNDEF NODE_IS_CLASS}
  PNode = ^TNode;
  {$ELSE}
  TNode = class;
  PNode = TNode;
  {$ENDIF}
  TNode = {$IFDEF NODE_IS_CLASS}class protected{$ELSE}record{$ENDIF}
    left, right: PNode;
    parent: Int32;
    {$IFNDEF NODE_IS_CLASS}
    data: TTreeData;
    {$ELSE}
    procedure MoveFrom(Source: TNode); virtual; abstract;
    {$ENDIF}
  end;

  {$IFDEF NODE_IS_CLASS}
  TTreeData = TNode;
  {$ENDIF}

  ERBTreeError = class(Exception);

  {$IFDEF USER_COMPARE}
  {$DEFINE RBTREE_USER_COMPARE}
  TRBTreeCompareFunc = function (const a, b: TTreeData): Integer;
  {$ENDIF}

  {$IFDEF USER_COMPARE_OBJECTS}
  {$DEFINE RBTREE_USER_COMPARE}
  TRBTreeCompareFunc = function (const a, b: TTreeData): Integer of object;
  {$ENDIF}

  TTraverseProc = procedure (const Item: TTreeData) of object;

  TRBTree = class
  protected
    root, TNIL: PNode;
    FCount: Integer;
    {$IFDEF RBTREE_USER_COMPARE}
    CMP: TRBTreeCompareFunc;
    {$ENDIF}
    {$IFDEF VIRTUAL_COMPARE}
    function CMP(const a, b: TTreeData): Integer; virtual; abstract;
    {$ENDIF}
    {$IFDEF NON_VIRTUAL_COMPARE}
    function CMP(const a, b: TTreeData): Integer;
      {$IFDEF V_INLINE}{$IFDEF INLINE_COMPARE}inline;{$ENDIF}{$ENDIF}
    {$ENDIF}
    {$IFDEF NODE_IS_CLASS}
    function CreateNode: TNode; virtual;
    {$ENDIF}
    procedure WriteItem(VStream: TVStream; const Item: TTreeData); virtual;
    function ReadItem(VStream: TVStream): TTreeData; virtual;
    procedure RotateLeft(x: PNode);
    procedure RotateRight(x: PNode);
  public
    {$IFDEF RBTREE_USER_COMPARE}
    constructor Create(CMPFunc: TRBTreeCompareFunc);
    {$ELSE}
    constructor Create;
    {$ENDIF}
    destructor Destroy; override;
    procedure WriteToStream(VStream: TVStream);
    procedure ReadFromStream(VStream: TVStream);
    procedure Clear;
    { очищает дерево }
    { clears the tree }

    { низкоуровневые методы }
    { low-level methods }
    function FFindNode(const Item: TTreeData; var Node: PNode): Boolean;
    function FInsertNode(const Item: TTreeData; Current: PNode): PNode;
    function InsertNode(const Item: TTreeData; var NewNode: Boolean): PNode;
    { если в дереве нет значений, равных Item (равенство определяется CMP), то
      добавляет Item в дерево и записывает True в NewNode, иначе записывает
      False в NewNode; в обоих случаях возвращает указатель на узел дерева,
      содержащий Item }
    { if there are no values equal to Item in the tree (according to CMP) then
      adds Item to the tree and sets NewNode to True else sets NewNode to False;
      in either case returns the pointer to the tree node containing Item }
    procedure DeleteNode(z: PNode);
    { удаляет узел из дерева }
    { deletes the node from the tree }
    function FindNode(const Item: TTreeData): PNode;
    { возвращает указатель на узел дерева, значение которого равно Item, если
      такой существует, и nil иначе }
    { returns the pointer to the tree node which value is equal to Item if such
      node exists or nil otherwise }
    function AddNode(const Item: TTreeData): PNode;
    { аналогично Add (см. ниже), но возвращается указатель на добавленный или
      существоваший узел дерева, значение которого равно Item }
    { analogous to Add (see below) but returns the pointer to the added or
      existed tree node containing Item }
    function MinNode: PNode;
    { возвращает указатель на минимальный (в соответствии с CMP) узел дерева,
      если оно не пусто, и nil иначе }
    { returns the pointer to the minimum (according to CMP) tree node if the
      tree isn't empty or nil otherwise }
    function MaxNode: PNode;
    { возвращает указатель на максимальный (в соответствии с CMP) узел дерева,
      если оно не пусто, и nil иначе }
    { returns the pointer to the maximum (according to CMP) tree node if the
      tree isn't empty or nil otherwise }

    { "пользовательские" методы }
    { "user" methods }
    function IsEmpty: Boolean;
    { возвращает True, если дерево пусто, и False иначе }
    { returns True if the tree is empty or False otherwise }
    function Add(const Item: TTreeData): Boolean; {$IFDEF V_INLINE}inline;{$ENDIF}
    { если в дереве нет значений, равных Item (равенство определяется CMP), то
      добавляет Item в дерево и возвращает True, иначе возвращает False }
    { if there are no values equal to Item in the tree (equality is defined by
      CMP) then adds Item to the tree and returns True else False }
    function Find(const Item: TTreeData): Boolean; {$IFDEF V_INLINE}inline;{$ENDIF}
    { возвращает True, если в дереве есть значение, равное Item (равенство
      определяется CMP), и False иначе }
    { if there are no values equal to Item in the tree (equality is defined by
      CMP) then returns True else False }
    function FindLessEqual(const Item: TTreeData; var FoundItem: TTreeData): Boolean;
    { ищет значение, меньшее либо равное Item, и при этом "ближайшее" к Item (в
      смысле абсолютного значения CMP); в случае успеха возвращает это значение
      в FoundItem; результат равен True, если такое значение существует, иначе
      False }
    { searches for a value which is less then or equal to Item and is also the
      "nearest" to Item (in the sense of the absolute value of CMP);
      if successful then returns this value in FoundItem; the result is equal
      to True if the specified value exists, otherwise False }
    function FindGreaterEqual(const Item: TTreeData; var FoundItem: TTreeData): Boolean;
    { аналогично FindLessEqual, но ищет значение, большее либо равное Item }
    { analog of FindLessEqual, but it searches for a key which is greater or
      equal then Item }
    procedure Delete(const Item: TTreeData); {$IFDEF V_INLINE}inline;{$ENDIF}
    { удаляет из дерева значение, равное Item (равенство определяется CMP);
      если значение не найдено, то возбуждается исключение ERBTreeError }
    { deletes a value equal to Item (equality is defined by CMP) from the tree;
      if the value wasn't found then raises exception ERBTreeError }
    function SafeDelete(const Item: TTreeData): Boolean;
    { если значение, равное Item (равенство определяется CMP), найдено в дереве,
      то удаляет его и возвращает True, иначе возвращает False }
    { if a value equal to Item (equality is defined by CMP) is found in the
      tree then deletes it and returns True, otherwise returns False }
    function ChangeItem(const OldItem, NewItem: TTreeData): Boolean;
    { заменяет значение, равное OldItem (равенство определяется CMP), на NewItem
      и возвращает True, если значения, равного NewItem, не было в дереве (т.е.
      NewItem было добавлено в дерево), и False иначе; если значение OldItem
      не найдено, то возбуждается исключение ERBTreeError }
    { changes the value equal to OldItem (equality is defined by CMP) to NewItem
      and returns True if there wasn't a value equal to NewItem in the tree (i.e.
      NewItem was added to the tree) or False otherwise; if OldItem wasn't found
      then raises exception ERBTreeError }
    {$IFNDEF NODE_IS_CLASS}
    function Min: TTreeData;
    { возвращает минимальное (в соответствии с CMP) значение, если дерево
      не пусто, иначе возбуждается исключительная ситуация, как при попытке
      обращения по nil-указателю }
    { returns the minimum (according to CMP) value in the tree if the tree isn't
      empty, otherwise exception is raised as when attempting to dereference
      nil-pointer }
    function Max: TTreeData;
    { возвращает максимальное (в соответствии с CMP) значение, если дерево
      не пусто, иначе возбуждается исключительная ситуация, как при попытке
      обращения по nil-указателю }
    { returns the maximum (according to CMP) value in the tree if the tree isn't
      empty, otherwise exception is raised as when attempting to dereference
      nil-pointer }
    {$ENDIF}
    procedure Traversal(TraverseProc: TTraverseProc);
    { обход дерева в произвольном (неопределенном) порядке }
    { tree traversal in some indefinite order }
    procedure UpwardTraversal(TraverseProc: TTraverseProc);
    { обход дерева в порядке от минимального значения к максимальному }
    { tree traversal from the minimum value to the maximum }
    procedure DownwardTraversal(TraverseProc: TTraverseProc);
    { обход дерева в порядке от максимального значения к минимальному }
    { tree traversal from the maximum value to the minimum }
    function FindDepth: Integer;
    { возвращает высоту дерева (для тестовых целей) }
    { returns a depth of the tree (for testing purposes) }
    property Count: Integer read FCount;
    { возвращает количество значений в дереве }
    { returns the number of values in the tree }
    {$IFDEF NODE_IS_CLASS}
    property Min: TTreeData read MinNode;
    property Max: TTreeData read MaxNode;
    {$ENDIF}
  end;

  TRBTreeIterator = class
  protected
    FRBTree: TRBTree;
    FCurrent: PNode;
    FBOF, FEOF: Boolean;
  public
    constructor Create(ARBTree: TRBTree);
    {$IFDEF CHECK_OBJECTS_FREE}
    destructor Destroy; override;
    {$ENDIF}
    procedure First;
    { переход на первый элемент дерева (элемент с минимальным значением) }
    { positions iterator on the first element (the element with the minimum
      value) }
    procedure Last;
    { переход на последний элемент дерева (элемент с максимальным значением) }
    { positions iterator on the last element (the element with the maximum
      value) }
    function Next: Boolean;
    { переход к следующему элементу дерева; возвращает True, если такой элемент
      существует (т.е. текущий элемент не является максимальным), иначе False;
      предусловие: EOF = False (в противном случае возбуждается исключение) }
    { positions iterator on the next element; returns True if such element
      exists (i.e. the current element is not maximum) or False otherwise;
      precondition: EOF = False (otherwise exception is raised) }
    function Prior: Boolean;
    { переход к предыдущему элементу дерева; возвращает True, если такой элемент
      существует (т.е. текущий элемент не является минимальным), иначе False;
      предусловие: BOF = False (в противном случае возбуждается исключение) }
    { positions iterator on the prior element; returns True if such element
      exists (i.e. the current element is not minimum) or False otherwise;
      precondition: BOF = False (otherwise exception is raised) }
    function Find(const Item: TTreeData): Boolean;
    { если Item входит в дерево, то позиционирует итератор на элемент Item и
      возвращает True, иначе возвращает False }
    { locates Item in the tree and if it was found then positions iterator on it
      and returns True, otherwise returns False }
    function Data: TTreeData; {$IFDEF V_INLINE}inline;{$ENDIF}
    { возвращает значение текущего элемент, если он существует (т.е. дерево
      не пусто), иначе возвращает nil }
    { returns the value at the current iterator position if the tree is not
      empty or nil otherwise }
    property BOF: Boolean read FBOF;
    { True, если достигнуто состояние BOF }
    { True if BOF reached }
    property Eof: Boolean read FEOF;
    { True, если достигнуто состояние EOF }
    { True if EOF reached }
    property Current: PNode read FCurrent;
    { текущий узел итерируемого дерева }
    { current node of the iterated tree }
    property RBTree: TRBTree read FRBTree;
    { итерируемое дерево }
    { the iterated tree }
  end;
